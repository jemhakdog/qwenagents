import winreg

def installed_apps():
    apps = []
    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall")
    for i in range(winreg.QueryInfoKey(key)[0]):
        subkey = winreg.EnumKey(key, i)
        try:
            app_key = winreg.OpenKey(key, subkey)
            app_name = winreg.QueryValueEx(app_key, "DisplayName")[0]
            apps.append(app_name)
        except:
            pass
    return apps


import json
import json5
import psutil
from qwen_agent.tools.base import BaseTool, register_tool
import subprocess
@register_tool('app_manager')
class AppManager(BaseTool):
    description = 'Manage applications actions such as running apps and stopping/closing them and view running and available apps.'
    parameters = [
        {
            'name': 'action',
            'type': 'string',
            'description': 'The action to perform (view_available, view_running, stop)',
            'required': True
        },
        {
            'name': 'app_name',
            'type': 'string',
            'description': 'The name of the app to stop (optional)',
            'required': False
        },
    ]

    def call(self, params: str, **kwargs) -> str:
        # `params` are the arguments generated by the LLM agent.
        action = json5.loads(params)['action']
        app_name = json5.loads(params).get('app_name')

        if action == 'view_available':
            available_apps = self.get_available_apps()
            return json.dumps(available_apps)

        elif action == 'view_running':
            running_apps = self.get_running_apps()
            return json.dumps(running_apps)

        elif action == 'stop':
            if not app_name:
                return json.dumps({'error': 'App name is required to stop'})
            stopped = self.stop_app(app_name)
            print(stopped,app_name)
            return json.dumps({'stopped': stopped})
        

        else:
            return json.dumps({'error': 'Invalid action'})

    def get_available_apps(self):
        return installed_apps()

    def get_running_apps(self):
        # Return a list of running apps
        running_apps = []
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                info = proc.info
                running_apps.append(info['name'])
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        return running_apps

    def stop_app(self, app_name):
        app_name = self.fix_app_name(app_name)
        try:
            subprocess.run(['taskkill', '/im', app_name, '/f'])
            return True
        except Exception as e:
            return False
        

    def fix_app_name(self, app_name):
        if not app_name.endswith(".exe"):
            app_name += ".exe"
        return app_name
    

