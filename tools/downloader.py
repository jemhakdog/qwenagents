# import requests
# import os
# import json
# from qwen_agent.tools.base import BaseTool, register_tool

# @register_tool('my_file_downloader')
# class MyFileDownloader(BaseTool):
#     description ='download a file from a given URL'
#     parameters = [
#         {
#             'name': 'urls',
#             'type': 'list',
#             'description': 'The URLs of the files to download',
#             'required': True
#         },
#         {
#             'name': 'filenames',
#             'type': 'list',
#             'description': 'The desired filenames for the downloaded files',
#             'required': True
#         },
#     ]

#     def call(self, params: str, **kwargs) -> str:
#         # `params` are the arguments generated by the LLM agent.
#         params_dict = json.loads(params)
#         urls = params_dict['urls']
#         filenames = params_dict['filenames']

#         # Check if the lengths of the lists match
#         if len(urls) != len(filenames):
#             return json.dumps({"message": "The number of URLs and filenames must match"})

#         # Initialize an empty list to store the results
#         results = []

#         # Iterate over the URLs and filenames
#         for url, filename in zip(urls, filenames):
#             # Send a GET request to the URL
#             response = requests.get(url, stream=True)

#             # Check if the request was successful
#             if response.status_code == 200:
#                 # Open a file in binary write mode
#                 with open(filename, 'wb') as f:
#                     # Iterate over the response chunks and write them to the file
#                     for chunk in response.iter_content(1024):
#                         f.write(chunk)
#                 results.append({"message": f"File downloaded successfully: {filename}"})
#             else:
#                 results.append({"message": f"Failed to download file: {response.status_code}"})

#         return json.dumps(results)


import requests
import os
import json
from qwen_agent.tools.base import BaseTool, register_tool
import concurrent.futures

@register_tool('my_file_downloader')
class MyFileDownloader(BaseTool):
    description ='download a file from a given URL'
    parameters = [
        {
            'name': 'urls',
            'type': 'list',
            'description': 'The URLs of the files to download',
            'required': True
        },
        {
            'name': 'filenames',
            'type': 'list',
            'description': 'The desired filenames for the downloaded files',
            'required': True
        },
    ]

    def call(self, params: str, **kwargs) -> str:
        # `params` are the arguments generated by the LLM agent.
        params_dict = json.loads(params)
        urls = params_dict['urls']
        filenames = params_dict['filenames']

        # Check if the lengths of the lists match
        if len(urls) != len(filenames):
            return json.dumps({"message": "The number of URLs and filenames must match"})

        # Initialize an empty list to store the results
        results = []

        # Define a function to download a single file
        def download_file(url, filename):
            response = requests.get(url, stream=True)
            if response.status_code == 200:
                with open(filename, 'wb') as f:
                    for chunk in response.iter_content(1024):
                        f.write(chunk)
                return {"message": f"File downloaded successfully: {filename}"}
            else:
                return {"message": f"Failed to download file: {response.status_code}"}

        # Use concurrent.futures to download all files concurrently
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [executor.submit(download_file, url, filename) for url, filename in zip(urls, filenames)]
            for future in concurrent.futures.as_completed(futures):
                results.append(future.result())

        return json.dumps(results)